<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Biblical Tapestry</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            color: #007bff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #hamburger {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 30px;
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            z-index: 10;
            display: block;
        }
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100%;
            background: #333;
            color: #fff;
            z-index: 9;
            padding: 60px 20px 20px;
            overflow-y: auto;
            display: none;
        }
        #menu.active {
            display: block;
        }
        #menu select {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: #444;
            color: #fff;
            border: none;
            border-radius: 3px;
        }
        @media (min-width: 769px) {
            #hamburger {
                display: none;
            }
            #menu {
                display: block;
                position: fixed;
                left: 0;
            }
            #verses-container, #split-container {
                margin-left: 250px;
            }
        }
        #verses-container {
            flex: 1;
            padding: 20px;
            color: #fff;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            cursor: pointer;
        }
        #verses-container.hidden {
            display: none;
        }
        #split-container {
            display: none;
            flex: 1;
            flex-direction: column;
            height: 100vh;
        }
        #top-half {
            flex: 1;
            padding: 20px;
            color: #fff;
            overflow-y: auto;
            border-bottom: 1px solid #007bff;
            position: relative;
        }
        #bottom-half {
            flex: 1;
            position: relative;
            overflow: auto;
            transition: flex 0.3s ease;
        }
        #bottom-half.hidden {
            flex: 0;
            height: 0;
        }
        #tapestry-container {
            position: absolute;
            width: 2000px;
            height: 300px;
        }
        .verse {
            margin: 10px 0;
            transition: color 0.3s ease;
            cursor: pointer;
        }
        .verse:hover {
            color: #007bff;
        }
        .node {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            z-index: 2;
            display: none;
        }
        .node.active {
            display: flex;
        }
        .node:hover {
            transform: scale(1.2);
        }
        .node.creation {
            background: #007bff;
        }
        .node.creation:hover {
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.8);
        }
        .node.spirit {
            background: #28a745;
        }
        .node.spirit:hover {
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.8);
        }
        .node span {
            font-size: 14px;
            color: #fff;
            font-weight: bold;
            text-align: center;
        }
        .thread {
            position: absolute;
            background: none;
            transform-origin: 0 0;
            transition: width 0.5s ease;
            z-index: 1;
            display: none;
        }
        .thread.active {
            display: block;
        }
        .thread.creation {
            border: 1px dashed #007bff;
        }
        .thread.spirit {
            border: 1px dashed #28a745;
        }
        .prompt {
            position: absolute;
            color: #fff;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 3;
            display: none;
        }
        .prompt.active {
            display: block;
            opacity: 1;
        }
        .thread-label {
            position: absolute;
            padding: 5px 10px;
            border-radius: 3px;
            color: #fff;
            font-weight: bold;
            z-index: 5;
            display: none;
        }
        .thread-label.active {
            display: block;
        }
        .thread-label.creation {
            background: #007bff;
        }
        .thread-label.spirit {
            background: #28a745;
        }
        #back-button, #close-button {
            position: absolute;
            background: #007bff;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        #back-button {
            top: 10px;
            right: 10px;
            display: none;
        }
        #close-button {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 5;
        }
        #back-button:hover, #close-button:hover {
            background: #0056b3;
        }
        .highlight {
            color: #007bff;
            font-weight: bold;
            background: rgba(0, 123, 255, 0.2);
            padding: 2px 5px;
        }
    </style>
</head>
<body>
    <!-- Hamburger Menu -->
    <button id="hamburger">☰</button>
    <div id="menu">
        <select id="book-select">
            <option value="">Select a Book</option>
        </select>
        <select id="chapter-select">
            <option value="">Select a Chapter</option>
        </select>
    </div>

    <!-- Initial Verses Display -->
    <div id="verses-container">
        <div class="verse" data-node="gen1">Loading...</div>
    </div>

    <!-- Split Screen -->
    <div id="split-container">
        <div id="top-half">
            <div id="verse-content"></div>
            <button id="back-button">Back</button>
        </div>
        <div id="bottom-half">
            <div id="tapestry-container"></div>
            <button id="close-button">Close</button>
        </div>
    </div>

    <script>
        const versesContainer = document.getElementById('verses-container');
        const splitContainer = document.getElementById('split-container');
        const bottomHalf = document.getElementById('bottom-half');
        const topHalf = document.getElementById('top-half');
        const verseContent = document.getElementById('verse-content');
        const backButton = document.getElementById('back-button');
        const closeButton = document.getElementById('close-button');
        const hamburger = document.getElementById('hamburger');
        const menu = document.getElementById('menu');
        const bookSelect = document.getElementById('book-select');
        const chapterSelect = document.getElementById('chapter-select');
        const tapestryContainer = document.getElementById('tapestry-container');

        // ESV API Key (replace with your own)
        const apiKey = 'c3be9ae20e39bd6637c709cd2e94fd42135764d1';
        const apiBase = 'https://api.esv.org/v3/passage/html/';

        // Book and chapter data
        const books = [
            { name: 'Genesis', chapters: 50, abbr: 'Gen' },
            { name: 'John', chapters: 21, abbr: 'John' },
            { name: 'Colossians', chapters: 4, abbr: 'Col' },
            { name: 'Revelation', chapters: 22, abbr: 'Rev' },
            { name: 'Job', chapters: 42, abbr: 'Job' },
            { name: 'Psalms', chapters: 150, abbr: 'Ps' },
            { name: 'Ezekiel', chapters: 48, abbr: 'Ezek' },
            { name: 'Acts', chapters: 28, abbr: 'Acts' }
        ];

        // Threads JSON
        const threadsData = {
            "creation": {
                "initialVerse": "gen1",
                "label": "Creation",
                "color": "#007bff",
                "nodes": [
                    { "id": "gen1", "passage": "Genesis 1:1", "label": "Gen 1:1", "question": "How does this begin God’s order?" },
                    { "id": "gen2-creation", "passage": "Genesis 1:2", "label": "Gen 1:2", "question": "What was the state of creation?" },
                    { "id": "john1", "passage": "John 1:1", "label": "John 1:1", "question": "How is Christ the Word revealed?" },
                    { "id": "col1", "passage": "Colossians 1:16", "label": "Col 1:16", "question": "What does this say about Christ’s role?" },
                    { "id": "rev21", "passage": "Revelation 21:1", "label": "Rev 21:1", "question": "How does creation renew?" },
                    { "id": "rev22", "passage": "Revelation 22:13", "label": "Rev 22:13", "question": "Who holds the end and beginning?" }
                ]
            },
            "spirit": {
                "initialVerse": "gen2",
                "label": "Spirit",
                "color": "#28a745",
                "nodes": [
                    { "id": "gen2", "passage": "Genesis 1:2", "label": "Gen 1:2", "question": "What moved over the waters?" },
                    { "id": "job26", "passage": "Job 26:13", "label": "Job 26:13", "question": "How does the Spirit form?" },
                    { "id": "ps104", "passage": "Psalm 104:30", "label": "Ps 104:30", "question": "What renews the earth?" },
                    { "id": "ez37", "passage": "Ezekiel 37:9", "label": "Ezek 37:9", "question": "How does breath revive?" },
                    { "id": "jn3", "passage": "John 3:5", "label": "John 3:5", "question": "What births anew?" },
                    { "id": "acts2", "passage": "Acts 2:2", "label": "Acts 2:2", "question": "How does the Spirit descend?" }
                ]
            }
        };

        // Verse to threads mapping
        const verseThreads = {
            'gen1': ['creation'],
            'gen2': ['creation', 'spirit']
        };

        // Dynamic node positions
        const nodePositions = {};
        let yOffset = 70; // Starting Y position
        const xSpacing = 200; // Horizontal spacing between nodes
        Object.keys(threadsData).forEach((threadType, index) => {
            const thread = threadsData[threadType];
            const labelY = yOffset - 30; // Label 30px above nodes
            thread.labelY = labelY;
            thread.nodes.forEach((node, nodeIndex) => {
                nodePositions[node.id] = {
                    x: 100 + nodeIndex * xSpacing,
                    y: yOffset
                };
            });
            yOffset += 100; // Space between threads
        });

        // Populate tapestry container
        Object.keys(threadsData).forEach(threadType => {
            const thread = threadsData[threadType];
            // Thread Label
            const label = document.createElement('div');
            label.className = `thread-label ${threadType}`;
            label.id = `label-${threadType}`;
            label.textContent = thread.label;
            label.style.top = `${thread.labelY}px`;
            label.style.left = '100px';
            tapestryContainer.appendChild(label);

            // Nodes
            thread.nodes.forEach((node, index) => {
                const nodeEl = document.createElement('div');
                nodeEl.className = `node ${threadType}`;
                nodeEl.id = node.id;
                nodeEl.style.top = `${nodePositions[node.id].y}px`;
                nodeEl.style.left = `${nodePositions[node.id].x}px`;
                nodeEl.innerHTML = `<span>${node.label}</span>`;
                tapestryContainer.appendChild(nodeEl);

                // Prompt
                const prompt = document.createElement('div');
                prompt.className = `prompt ${threadType}`;
                prompt.id = `prompt-${node.id}`;
                prompt.textContent = node.question;
                prompt.style.top = `${nodePositions[node.id].y + 70}px`;
                prompt.style.left = `${nodePositions[node.id].x}px`;
                tapestryContainer.appendChild(prompt);

                // Thread (edge) if not last node
                if (index < thread.nodes.length - 1) {
                    const threadEl = document.createElement('div');
                    threadEl.className = `thread ${threadType}`;
                    threadEl.id = `thread-${threadType}-${index}`;
                    tapestryContainer.appendChild(threadEl);
                }
            });
        });

        let activeNodes = new Set();
        let currentChapter = '';

        // Populate book select
        books.forEach(book => {
            const option = document.createElement('option');
            option.value = book.abbr;
            option.textContent = book.name;
            bookSelect.appendChild(option);
        });

        // Update chapter select
        bookSelect.addEventListener('change', () => {
            chapterSelect.innerHTML = '<option value="">Select a Chapter</option>';
            const book = books.find(b => b.abbr === bookSelect.value);
            if (book) {
                for (let i = 1; i <= book.chapters; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `Chapter ${i}`;
                    chapterSelect.appendChild(option);
                }
            }
        });

        // Fetch chapter from ESV API
        async function fetchChapter(book, chapter) {
            const passage = `${book} ${chapter}`;
            try {
                const response = await fetch(`${apiBase}?q=${encodeURIComponent(passage)}&include-verse-numbers=true`, {
                    headers: { 'Authorization': `Token ${apiKey}` }
                });
                const data = await response.json();
                return data.passages[0] || 'Error loading chapter.';
            } catch (error) {
                console.error('API Error:', error);
                return 'Error loading chapter.';
            }
        }

        // Load initial chapter
        async function loadInitialChapter() {
            const text = await fetchChapter('Genesis', 1);
            versesContainer.innerHTML = text;
            addVerseClickListeners(versesContainer);
        }
        loadInitialChapter();

        // Hamburger menu toggle
        hamburger.addEventListener('click', () => {
            menu.classList.toggle('active');
        });

        // Chapter selection
        chapterSelect.addEventListener('change', async () => {
            if (bookSelect.value && chapterSelect.value) {
                const book = books.find(b => b.abbr === bookSelect.value).name;
                const chapter = chapterSelect.value;
                currentChapter = `${book} ${chapter}`;
                const text = await fetchChapter(book, chapter);
                versesContainer.innerHTML = text;
                versesContainer.classList.remove('hidden');
                splitContainer.style.display = 'none';
                addVerseClickListeners(versesContainer);
                if (window.innerWidth <= 768) menu.classList.remove('active');
            }
        });

        // Draw thread
        function drawThread(startNode, endNode, threadElement) {
            const start = nodePositions[startNode];
            const end = nodePositions[endNode];
            const length = end.x - start.x;

            threadElement.style.width = '0px';
            threadElement.style.height = '1px';
            threadElement.style.left = `${start.x}px`;
            threadElement.style.top = `${start.y}px`;
            threadElement.style.transform = `rotate(0deg)`;

            threadElement.classList.add('active');
            setTimeout(() => {
                threadElement.style.width = `${length}px`;
            }, 100);
        }

        // Pan to node
        function panToNode(node) {
            const nodeRect = node.getBoundingClientRect();
            const bottomRect = bottomHalf.getBoundingClientRect();
            const scrollX = nodeRect.left - bottomRect.left + bottomHalf.scrollLeft - (bottomHalf.offsetWidth / 2) + 30;
            const scrollY = nodeRect.top - bottomRect.top + bottomHalf.scrollTop - (bottomHalf.offsetHeight / 2) + 30;

            bottomHalf.scrollTo({ left: scrollX, top: scrollY, behavior: 'smooth' });
        }

        // Show chapter with highlighted verse
        async function showVerseContext(nodeId) {
            const node = Object.values(threadsData).flatMap(t => t.nodes).find(n => n.id === nodeId);
            const passage = node.passage;
            const [book, ref] = passage.split(' ');
            const chapter = ref.split(':')[0];
            const verseNum = ref.split(':')[1];
            currentChapter = `${book} ${chapter}`;
            const text = await fetchChapter(book, chapter);
            verseContent.innerHTML = text;
            const verses = verseContent.querySelectorAll('.v');
            verses.forEach(v => {
                v.classList.remove('highlight');
                if (v.textContent.trim().startsWith(verseNum)) {
                    v.classList.add('highlight');
                    v.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
            backButton.style.display = 'block';
            addVerseClickListeners(verseContent);
        }

        // Restore previous chapter
        async function restoreChapter() {
            if (currentChapter) {
                const [book, chapter] = currentChapter.split(' ');
                const text = await fetchChapter(book, chapter);
                verseContent.innerHTML = text;
                backButton.style.display = 'none';
                addVerseClickListeners(verseContent);
            }
        }

        // Show threads
        function showThreads(nodeId) {
            const threadLabels = document.querySelectorAll('.thread-label');
            const nodes = document.querySelectorAll('.node');
            const threads = document.querySelectorAll('.thread');
            const prompts = document.querySelectorAll('.prompt');

            threadLabels.forEach(label => label.classList.remove('active'));
            nodes.forEach(node => node.classList.remove('active'));
            threads.forEach(thread => thread.classList.remove('active'));
            prompts.forEach(prompt => prompt.classList.remove('active'));

            const verseKey = nodeId.includes('creation') ? 'gen2-creation' : nodeId;
            const threadTypes = verseThreads[verseKey.split('-')[0]] || [Object.keys(threadsData).find(type => threadsData[type].nodes.some(n => n.id === nodeId))];

            threadTypes.forEach(threadType => {
                const label = document.getElementById(`label-${threadType}`);
                if (label) label.classList.add('active');

                const threadNodes = threadsData[threadType].nodes;
                threadNodes.forEach(node => {
                    const el = document.getElementById(node.id);
                    if (activeNodes.has(node.id)) {
                        el.classList.add('active');
                        const prompt = document.getElementById(`prompt-${node.id}`);
                        if (prompt && node.id === nodeId) prompt.classList.add('active');
                    }
                });

                for (let i = 0; i < threadNodes.length - 1; i++) {
                    if (activeNodes.has(threadNodes[i].id) && activeNodes.has(threadNodes[i + 1].id)) {
                        const threadIndex = threadType === 'creation' ? i : i + 5;
                        threads[threadIndex].classList.add('active');
                    }
                }
            });
        }

        // Open bottom half
        function openBottom(nodeId) {
            versesContainer.classList.add('hidden');
            splitContainer.style.display = 'flex';
            bottomHalf.classList.remove('hidden');
            topHalf.style.flex = '1';

            const node = document.getElementById(nodeId);
            if (!activeNodes.has(nodeId)) {
                activeNodes.add(nodeId);
                node.classList.add('active');
            }

            showThreads(nodeId);
            panToNode(node);
            showVerseContext(nodeId);
        }

        // Close bottom half
        function closeBottom() {
            bottomHalf.classList.add('hidden');
            topHalf.style.flex = '1';
            document.querySelectorAll('.prompt').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.thread-label').forEach(label => label.classList.remove('active'));
            activeNodes.clear();
            document.querySelectorAll('.node').forEach(node => node.classList.remove('active'));
            document.querySelectorAll('.thread').forEach(thread => thread.classList.remove('active'));
        }

        // Add verse click listeners
        function addVerseClickListeners(container) {
            const verses = container.querySelectorAll('.p');
            verses.forEach(verse => {
                verse.addEventListener('click', () => {
                    const node = Object.values(threadsData).flatMap(t => t.nodes).find(n => {
                        const passage = n.passage;
                        return verse.textContent.includes(passage.split(':')[1]);
                    });
                    if (node) openBottom(node.id);
                });
            });
        }

        // Initial split screen
        versesContainer.addEventListener('click', () => {
            openBottom('gen1');
        });

        // Node interaction
        document.querySelectorAll('.node').forEach(node => {
            node.addEventListener('click', () => {
                const threadType = Object.keys(threadsData).find(type => threadsData[type].nodes.some(n => n.id === node.id));
                const threadNodes = threadsData[threadType].nodes;
                const nodeIndex = threadNodes.findIndex(n => n.id === node.id);

                if (!activeNodes.has(node.id)) {
                    activeNodes.add(node.id);
                    node.classList.add('active');
                }

                document.querySelectorAll('.prompt').forEach(p => p.classList.remove('active'));
                const prompt = document.getElementById(`prompt-${node.id}`);
                if (prompt) prompt.classList.add('active');

                panToNode(node);
                showVerseContext(node.id);

                if (nodeIndex < threadNodes.length - 1 && !activeNodes.has(threadNodes[nodeIndex + 1].id)) {
                    const nextNode = threadNodes[nodeIndex + 1].id;
                    activeNodes.add(nextNode);
                    document.getElementById(nextNode).classList.add('active');
                    const threadOffset = threadType === 'creation' ? 0 : 5;
                    drawThread(node.id, nextNode, document.getElementById(`thread-${threadType}-${nodeIndex}`));
                }

                showThreads(node.id);
            });
        });

        // Back button
        backButton.addEventListener('click', restoreChapter);

        // Close button
        closeButton.addEventListener('click', closeBottom);
    </script>
</body>
</html>